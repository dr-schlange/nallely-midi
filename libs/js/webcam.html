<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nallely External Device Webcam Integration Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/dr-schlange/nallely-midi@main/libs/js/nallely-websocket.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <h1>Nallely External Device Webcam Integration Demo</h1>

    <div>
        <label for="address">Server Address:</label>
        <input type="text" id="address" value="" placeholder="hostname:port" />
        <button id="connect-btn">Connect</button>
    </div>
    <div id="status">Status: <span id="connection-status">Disconnected</span></div>

    <video id="camera-feed" autoplay></video>
    <canvas id="canvas" style="display:none;"></canvas>
    <p>Brightness avg: <span id="brightness">0</span></p>
    <p>Index finger angle: <span id="finger">0</span></p>
    <script>
        const addressInput = document.getElementById('address');
        const connectBtn = document.getElementById('connect-btn');

        const configParameters = {
            brightness: { min: 0.0, max: 255.01 },
            indexFingerAngle: { min: 0.1, max: 1 },
        }
        const config = {
            brightness: 0.0,
            indexFingerAngle: 0.1,
        }

        // connect to a given websocket bus address
        let device = null;
        function connectToAddress(address) {
            if (device) {
                device.dispose();
            }

            updateStatus(`Connecting on ${address}...`);

            device = NallelyWebsocketBus.register('webcam', 'cam', configParameters, config, address);

            device.onopen = () => updateStatus('Connected');
            device.onclose = () => updateStatus('Disconnected');
            device.onerror = () => updateStatus('Error');
        }

        addressInput.value = `${window.location.hostname}:6789`;
        connectToAddress(addressInput.value);

        function handleConnect() {
            const address = addressInput.value.trim();
            if (!address) {
                addressInput.value = `${window.location.hostname}:6789`;
                connectToAddress(addressInput.value);
            } else {
                connectToAddress(address);
            }
        }

        connectBtn.addEventListener('click', handleConnect);
        addressInput.addEventListener('change', handleConnect);
        addressInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                handleConnect();
            }
        });

        // Update connection status based on WebSocket events
        function updateStatus(status) {
            document.getElementById('connection-status').textContent = status;
        }

        // Compute brightness from webcam feed
        const video = document.getElementById('camera-feed');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const brightnessDisplay = document.getElementById('brightness');
        const fingerDisplay = document.getElementById('finger');

        window.addEventListener('load', function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                    video.srcObject = stream;

                    video.addEventListener('loadeddata', () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;

                        // Measure brightness every 200ms
                        setInterval(() => {
                            // capture the current frame
                            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imageData.data;

                            let total = 0;
                            const len = data.length / 4;

                            // compute average brightness
                            for (let i = 0; i < data.length; i += 4) {
                                const r = data[i];
                                const g = data[i + 1];
                                const b = data[i + 2];

                                const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
                                total += brightness;
                            }

                            const avgBrightness = total / len;
                            brightnessDisplay.textContent = avgBrightness.toFixed(2);
                            device.send("brightness", avgBrightness)
                        }, 200);
                    });
                })
                .catch(error => {
                    console.error('Error accessing camera:', error);
                });
        });

        // Hand tracking with MediaPipe
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });

        function isIndexUp(landmarks) {
            const tip = landmarks[8];     // Index tip
            const mcp = landmarks[5];     // Index base

            return tip.y < mcp.y;
        }

        function getIndexAngle(landmarks) {
            const mcp = landmarks[5];  // base
            const pip = landmarks[6];  // First knuckle
            const tip = landmarks[8];  // fingertip

            const vecA = {
                x: mcp.x - pip.x,
                y: mcp.y - pip.y,
                z: mcp.z - pip.z
            };

            const vecB = {
                x: tip.x - pip.x,
                y: tip.y - pip.y,
                z: tip.z - pip.z
            };

            const dot = vecA.x * vecB.x + vecA.y * vecB.y + vecA.z * vecB.z;
            const magA = Math.sqrt(vecA.x ** 2 + vecA.y ** 2 + vecA.z ** 2);
            const magB = Math.sqrt(vecB.x ** 2 + vecB.y ** 2 + vecB.z ** 2);

            const angleRad = Math.acos(dot / (magA * magB));
            const angleDeg = angleRad * (180 / Math.PI);
            return angleDeg;
        }

        function getIndexLiftingRatio(angleDeg) {
            const min = 60;  // closed fist
            const max = 170; // fully extended finger
            return Math.min(1, Math.max(0, (angleDeg - min) / (max - min)));
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0]; // main 0
                const angle = getIndexAngle(landmarks);
                const ratio = getIndexLiftingRatio(angle);

                fingerDisplay.textContent = Number.parseFloat(ratio.toFixed(2));
                device.send("indexFingerAngle", Number.parseFloat(ratio.toFixed(2)))
            }
        }


        hands.onResults(onResults);


        // Associate the camera feed with MediaPipe Hands
        const camera = new Camera(video, {
            onFrame: async () => {
                await hands.send({ image: video });
            },
            width: 640,
            height: 480
        });
        camera.start();


    </script>

</body>

</html>